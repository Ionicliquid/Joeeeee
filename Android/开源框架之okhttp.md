# 基础知识
## TCP与UDP

TCP（传输控制协议）和UDP（用户数据报协议）是传输层的两大核心协议，它们在设计目标和应用场景上有显著差异。以下是它们的主要区别：

---

### **1. 连接方式**
- **TCP**：面向连接。  
  传输数据前需通过**三次握手**建立连接，结束后通过**四次挥手**断开连接。
- **UDP**：无连接。  
  直接发送数据，无需预先建立或断开连接。

---

### **2. 可靠性**
- **TCP**：**可靠传输**。  
  通过确认应答（ACK）、超时重传、数据校验等机制确保数据**不丢失、不重复、按序到达**。
- **UDP**：**不可靠传输**。  
  无确认、重传机制，数据可能丢失或乱序。

---

### **3. 传输效率**
- **TCP**：效率较低。  
  因连接管理、可靠性机制等额外开销，传输延迟较高。
- **UDP**：效率高。  
  无复杂控制机制，传输速度快，实时性更好。

---

### **4. 数据顺序**
- **TCP**：保证数据顺序。  
  接收方按发送顺序处理数据包。
- **UDP**：不保证顺序。  
  数据包可能乱序到达，需应用层自行处理。

---

### **5. 流量控制与拥塞控制**
- **TCP**：  
  - **流量控制**：通过滑动窗口机制，防止发送方过载接收方。  
  - **拥塞控制**：通过慢启动、拥塞避免等算法动态调整发送速率。
- **UDP**：无流量和拥塞控制，可能加剧网络拥塞。

---

### **6. 头部开销**
- **TCP**：头部较大（**20~60字节**），包含序列号、确认号、窗口大小等控制信息。  
- **UDP**：头部固定仅**8字节**，更轻量。

---

### **7. 数据边界**
- **TCP**：**流式传输**。  
  无明确数据边界，接收方可能合并多次发送的数据（如发送两次100字节数据，可能一次接收200字节）。  
- **UDP**：**数据报传输**。  
  保留发送时的数据边界（发送两次100字节数据，接收方分两次读取）。

---

### **8. 传输模式**
- **TCP**：仅支持**一对一**通信。  
- **UDP**：支持**一对一、一对多、多对多**（广播、多播）。

---

### **9. 应用场景**
- **TCP**：  
  适用于对可靠性要求高的场景，如：  
  - 网页浏览（HTTP/HTTPS）  
  - 文件传输（FTP）  
  - 电子邮件（SMTP/POP3）  
  - 数据库连接  

- **UDP**：  
  适用于实时性优先的场景，如：  
  - 实时视频/语音通话（Zoom、VoIP）  
  - 在线游戏（低延迟需求）  
  - DNS查询  
  - 物联网传感器数据传输  

---

### **总结对比表**
| 特性                | TCP                                  | UDP                                  |
|---------------------|--------------------------------------|--------------------------------------|
| **连接方式**        | 面向连接（三次握手）                | 无连接                               |
| **可靠性**          | 可靠传输（确认、重传机制）          | 不可靠传输                           |
| **传输效率**        | 较低（控制机制复杂）                | 较高（轻量级）                       |
| **数据顺序**        | 保证顺序                            | 不保证顺序                           |
| **流量/拥塞控制**   | 支持                                | 不支持                               |
| **头部大小**        | 20~60字节                           | 8字节                                |
| **数据边界**        | 流式（无边界）                      | 数据报（保留边界）                   |
| **适用场景**        | 可靠性优先（文件传输、网页）        | 实时性优先（视频、游戏、广播）       |

---

### **如何选择？**
- **需要可靠传输**（如文件下载）：选TCP。  
- **需要低延迟或实时性**（如直播、游戏）：选UDP。  
- 某些应用（如QUIC/HTTP3）会在UDP上实现可靠性机制，结合两者优势。
## HTTP与HTTPS

### HTTPS的握手过程

HTTPS 的握手过程本质上是 **SSL/TLS 协议的握手过程**，用于在客户端（如浏览器）和服务器之间建立安全的加密通信通道。以下是 **TLS 1.2** 版本的典型握手流程（以 RSA 密钥交换为例）：

---

### **1. TCP 三次握手**
HTTPS 基于 TCP 协议，因此首先需完成 **TCP 三次握手**，建立 TCP 连接（非 TLS 握手内容，但必不可少）。

---

### **2. TLS 握手核心步骤**
#### **Step 1: Client Hello**
客户端向服务器发送 **Client Hello** 消息，包含：
- 支持的 **TLS 版本**（如 TLS 1.2、1.3）。
- 支持的 **加密套件**（Cipher Suites），如 `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`。
- 客户端生成的 **随机数**（Client Random）。

---

#### **Step 2: Server Hello**
服务器响应 **Server Hello** 消息，包含：
- 选择的 **TLS 版本**和**加密套件**。
- 服务器生成的 **随机数**（Server Random）。
- 服务器的 **数字证书**（包含公钥、域名、CA 签名等）。

---

#### **Step 3: 证书验证**
客户端验证服务器的证书：
1. 检查证书是否由受信任的 **CA（证书颁发机构）** 签发。
2. 检查证书是否在有效期内。
3. 检查证书中的域名是否与访问的域名匹配。
4. 验证证书链（根证书→中间证书→服务器证书）的完整性。

---

#### **Step 4: 密钥交换**
- **RSA 密钥交换**（传统方式）：
  客户端生成 **预主密钥（Pre-Master Secret）**，用服务器的公钥加密后发送给服务器。
- **ECDHE 密钥交换**（前向保密）：
  服务器发送 **Server Key Exchange** 消息，包含椭圆曲线参数和签名，客户端和服务器各自生成预主密钥。

---

#### **Step 5: 生成会话密钥**
客户端和服务器利用以下三个随机数生成 **会话密钥（Session Key）**：
1. Client Random
2. Server Random
3. Pre-Master Secret  
会话密钥用于后续通信的对称加密（如 AES）。

---

#### **Step 6: 完成握手**
1. 客户端发送 **Change Cipher Spec** 消息，告知服务器后续通信使用会话密钥加密。
2. 客户端发送 **Finished** 消息，包含握手过程的哈希值（供服务器验证完整性）。
3. 服务器同样发送 **Change Cipher Spec** 和 **Finished** 消息。

---

### **3. 加密通信**
握手完成后，客户端与服务器使用 **对称加密算法**（如 AES）加密数据，并通过 **MAC（消息认证码）** 或 **AEAD（如 GCM）** 保证数据完整性。

---

### **TLS 1.3 的优化**
TLS 1.3 大幅简化握手过程：
1. 合并 **Client Hello** 和 **密钥交换参数**。
2. 服务器在 **Server Hello** 中直接发送证书和密钥交换参数。
3. 握手仅需 **1-RTT（一次往返）**，甚至支持 **0-RTT**（快速恢复会话）。

---

### **流程图**
```
客户端                            服务器
  |----- Client Hello ------------>|
  |<---- Server Hello + Certificate + Server Key Exchange --|
  |----- Pre-Master Secret (加密) -->|
  |<---- Change Cipher Spec + Finished ----|
  |----- Change Cipher Spec + Finished --->|
  |<==== 加密通信开始 ===================>|
```

---

### **关键点总结**
1. **身份验证**：通过数字证书验证服务器身份。
2. **密钥交换**：安全协商对称加密的会话密钥。
3. **前向保密**：ECDHE 等算法确保即使长期私钥泄露，历史通信仍安全。
4. **性能优化**：TLS 1.3 减少握手延迟，提升速度。

---

### **常见问题**
- **为什么需要证书？**  
  防止中间人攻击，确保客户端连接的是真实的服务器。
- **RSA 与 ECDHE 的区别？**  
  ECDHE 支持前向保密，RSA 不支持。
- **TLS 握手会影响性能吗？**  
  是的，尤其是 RSA 密钥交换，但 TLS 1.3 和会话恢复（Session Resumption）可缓解这一问题。

## 一次网络请求的发起过程

# 分发器

# 拦截器

1. 请求的执行流程：构建请求 -> 分发器 -> 拦截器 -> 获得响应；
2. 分发器：内部维护队列与线程池，用来控制请求数与请求线程；
3. 拦截器：完成请求；
   1. RetryAndFollowUpInterceptor：重试与重定向
   2. BridgeInterceptor：桥接拦截器
   3. CacheInterceptor：缓存拦截器
   4. ConnectInterceptor：连接拦截器
   5. CallServerInterceptor：请求服务器拦截器

## RetryAndFollowUpInterceptor

1. 重试用来处理特定的IO异常和路由异常
   1. 重试是可配置
   2. 部分异常如协议异常，握手异常 证书异常 不能重试
   3. 存在更多路径选择，DNS解析返回了多个IP ，挨个重试` RouteSelector#resetNextInetSocketAddress`
2. 重定向 针对特定的返回码重新请求
   1. 407 客户端使用了代理，需要添加Proxy-Authorization请求头，并配置密码；
   2. 308：永久重定向，并且请求为Get形式

##  BridgeInterceptor

1. 补全请求头，HOST/User-Agent等
2. 对于使用Gzip 返回的响应，会通过GzipSource 之后 用于下游解析

##  CacheInterceptor

## ConnectInterceptor

1. 所谓的连接就是指一个Socket， 该拦截器的主要作用 就是维护一个连接池；
2. 连接被创建成功后会加入到连接队列中，并开启一个线程轮询检查队列；
3. 最大闲置数为五个，最长闲置时间为五分钟，超过之后按时间顺序清理，不满足条件则线程等待

## CallServerInterceptor

### 参考链接

